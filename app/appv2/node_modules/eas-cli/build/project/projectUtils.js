"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptToCreateProjectIfNotExistsAsync = exports.getBranchByNameAsync = exports.getProjectConfigDescription = exports.getProjectFullNameAsync = exports.getProjectIdAsync = exports.setProjectIdAsync = exports.findProjectRootAsync = exports.getProjectAccountNameAsync = exports.getUsername = exports.getProjectAccountName = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const graphql_tag_1 = (0, tslib_1.__importDefault)(require("graphql-tag"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const pkg_dir_1 = (0, tslib_1.__importDefault)(require("pkg-dir"));
const client_1 = require("../graphql/client");
const generated_1 = require("../graphql/generated");
const log_1 = (0, tslib_1.__importDefault)(require("../log"));
const prompts_1 = require("../prompts");
const actions_1 = require("../user/actions");
const ensureProjectExists_1 = require("./ensureProjectExists");
const expoConfig_1 = require("./expoConfig");
function getProjectAccountName(exp, user) {
    switch (user.__typename) {
        case 'User':
            return exp.owner || user.username;
        case 'Robot':
            if (!exp.owner) {
                throw new Error('The "owner" manifest property is required when using robot users. See: https://docs.expo.dev/versions/latest/config/app/#owner');
            }
            return exp.owner;
    }
}
exports.getProjectAccountName = getProjectAccountName;
function getUsername(exp, user) {
    switch (user.__typename) {
        case 'User':
            return user.username;
        case 'Robot':
            // owner field is necessary to run `expo prebuild`
            if (!exp.owner) {
                throw new Error('The "owner" manifest property is required when using robot users. See: https://docs.expo.dev/versions/latest/config/app/#owner');
            }
            // robot users don't have usernames
            return undefined;
    }
}
exports.getUsername = getUsername;
async function getProjectAccountNameAsync(exp) {
    const user = await (0, actions_1.ensureLoggedInAsync)();
    return getProjectAccountName(exp, user);
}
exports.getProjectAccountNameAsync = getProjectAccountNameAsync;
async function findProjectRootAsync({ cwd, defaultToProcessCwd = false, } = {}) {
    const projectRootDir = await (0, pkg_dir_1.default)(cwd);
    if (!projectRootDir) {
        if (!defaultToProcessCwd) {
            throw new Error('Please run this command inside a project directory.');
        }
        else {
            return process.cwd();
        }
    }
    else {
        return projectRootDir;
    }
}
exports.findProjectRootAsync = findProjectRootAsync;
async function setProjectIdAsync(projectDir, options = {}) {
    var _a, _b;
    const exp = (0, expoConfig_1.getExpoConfig)(projectDir, options);
    const privacy = toAppPrivacy(exp.privacy);
    const projectId = await (0, ensureProjectExists_1.ensureProjectExistsAsync)({
        accountName: getProjectAccountName(exp, await (0, actions_1.ensureLoggedInAsync)()),
        projectName: exp.slug,
        privacy,
    });
    const result = await (0, config_1.modifyConfigAsync)(projectDir, {
        extra: { ...exp.extra, eas: { ...(_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas, projectId } },
    });
    switch (result.type) {
        case 'success':
            break;
        case 'warn': {
            log_1.default.log();
            log_1.default.warn('It looks like you are using a dynamic configuration!');
            log_1.default.log(chalk_1.default.dim('https://docs.expo.dev/workflow/configuration/#dynamic-configuration-with-appconfigjs)\n'));
            log_1.default.warn('In order to finish setting up your project you are going to need manually add the following to your "extra" key:\n\n');
            log_1.default.log(chalk_1.default.bold(`"extra": {\n  ...\n  "eas": {\n    "projectId": "${projectId}"\n  }\n}`));
            throw new Error(result.message);
        }
        case 'fail':
            throw new Error(result.message);
        default:
            throw new Error('Unexpected result type from modifyConfigAsync');
    }
    log_1.default.withTick(`Linked app.json to project with ID ${chalk_1.default.bold(projectId)}`);
    /**
     * result.config will always be an AppJSONConfig if result.type === 'success'
     * PR to fix this typing: https://github.com/expo/expo-cli/pull/3482/files
     *
     * Code is written to safely handle the case where config type is not
     * AppJSONConfig (namely there will be no expo key and the result will be undefined).
     * TODO-JJ delete AppJSONConfig casting once typing is updated in the published @expo/config and
     * remove undefined alternative from return type
     */
    return (_b = result.config) === null || _b === void 0 ? void 0 : _b.expo;
}
exports.setProjectIdAsync = setProjectIdAsync;
async function getProjectIdAsync(exp, options = {}) {
    var _a, _b, _c, _d;
    if (!process.env.EAS_ENABLE_PROJECT_ID) {
        const privacy = toAppPrivacy(exp.privacy);
        return await (0, ensureProjectExists_1.ensureProjectExistsAsync)({
            accountName: getProjectAccountName(exp, await (0, actions_1.ensureLoggedInAsync)()),
            projectName: exp.slug,
            privacy,
        });
    }
    const localProjectId = (_b = (_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas) === null || _b === void 0 ? void 0 : _b.projectId;
    if (localProjectId) {
        return localProjectId;
    }
    // Set the project ID if it is missing.
    const projectDir = await findProjectRootAsync();
    if (!projectDir) {
        throw new Error('Please run this command inside a project directory.');
    }
    const newExp = await setProjectIdAsync(projectDir, options);
    const newLocalProjectId = (_d = (_c = newExp === null || newExp === void 0 ? void 0 : newExp.extra) === null || _c === void 0 ? void 0 : _c.eas) === null || _d === void 0 ? void 0 : _d.projectId;
    if (!newLocalProjectId) {
        // throw if we still can't locate the projectId
        throw new Error('Could not retrieve project ID from app.json');
    }
    return newLocalProjectId;
}
exports.getProjectIdAsync = getProjectIdAsync;
const toAppPrivacy = (privacy) => {
    if (privacy === 'public') {
        return generated_1.AppPrivacy.Public;
    }
    else if (privacy === 'hidden') {
        return generated_1.AppPrivacy.Hidden;
    }
    else {
        return generated_1.AppPrivacy.Unlisted;
    }
};
async function getProjectFullNameAsync(exp) {
    const accountName = await getProjectAccountNameAsync(exp);
    return `@${accountName}/${exp.slug}`;
}
exports.getProjectFullNameAsync = getProjectFullNameAsync;
/**
 * Return a useful name describing the project config.
 * - dynamic: app.config.js
 * - static: app.json
 * - custom path app config relative to root folder
 * - both: app.config.js or app.json
 */
function getProjectConfigDescription(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    if (paths.dynamicConfigPath) {
        const relativeDynamicConfigPath = path_1.default.relative(projectDir, paths.dynamicConfigPath);
        if (paths.staticConfigPath) {
            return `${relativeDynamicConfigPath} or ${path_1.default.relative(projectDir, paths.staticConfigPath)}`;
        }
        return relativeDynamicConfigPath;
    }
    else if (paths.staticConfigPath) {
        return path_1.default.relative(projectDir, paths.staticConfigPath);
    }
    return 'app.config.js/app.json';
}
exports.getProjectConfigDescription = getProjectConfigDescription;
async function getBranchByNameAsync({ appId, name, }) {
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .query((0, graphql_tag_1.default) `
          query ViewBranch($appId: String!, $name: String!) {
            app {
              byId(appId: $appId) {
                id
                updateBranchByName(name: $name) {
                  id
                  name
                }
              }
            }
          }
        `, {
        appId,
        name,
    }, { additionalTypenames: ['UpdateBranch'] })
        .toPromise());
    return data.app.byId.updateBranchByName;
}
exports.getBranchByNameAsync = getBranchByNameAsync;
// return project id of existing/newly created project, or null if user declines
async function promptToCreateProjectIfNotExistsAsync(exp) {
    const accountName = getProjectAccountName(exp, await (0, actions_1.ensureLoggedInAsync)());
    const maybeProjectId = await (0, ensureProjectExists_1.findProjectIdByAccountNameAndSlugNullableAsync)(accountName, exp.slug);
    if (maybeProjectId) {
        return maybeProjectId;
    }
    const fullName = await getProjectFullNameAsync(exp);
    const shouldCreateProject = await (0, prompts_1.confirmAsync)({
        message: `Looks like ${fullName} is new. Register it with EAS?`,
    });
    if (!shouldCreateProject) {
        return null;
    }
    const privacy = toAppPrivacy(exp.privacy);
    return await (0, ensureProjectExists_1.ensureProjectExistsAsync)({
        accountName,
        projectName: exp.slug,
        privacy,
    });
}
exports.promptToCreateProjectIfNotExistsAsync = promptToCreateProjectIfNotExistsAsync;
