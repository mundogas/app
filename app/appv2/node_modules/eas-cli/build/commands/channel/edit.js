"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateChannelBranchMappingAsync = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const graphql_tag_1 = (0, tslib_1.__importDefault)(require("graphql-tag"));
const EasCommand_1 = (0, tslib_1.__importDefault)(require("../../commandUtils/EasCommand"));
const client_1 = require("../../graphql/client");
const log_1 = (0, tslib_1.__importDefault)(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
async function getChannelByNameForAppAsync({ appId, channelName, }) {
    var _a;
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .query((0, graphql_tag_1.default) `
          query GetChannelByNameToEdit($appId: String!, $channelName: String!) {
            app {
              byId(appId: $appId) {
                id
                updateChannelByName(name: $channelName) {
                  id
                  name
                  updateBranches(offset: 0, limit: 1) {
                    id
                    name
                  }
                }
              }
            }
          }
        `, { appId, channelName }, { additionalTypenames: ['UpdateChannel', 'UpdateBranch'] })
        .toPromise());
    const updateChannelByNameResult = (_a = data.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName;
    if (!updateChannelByNameResult) {
        throw new Error(`Could not find a channel named ${channelName} on app with id ${appId}`);
    }
    return updateChannelByNameResult;
}
async function updateChannelBranchMappingAsync({ channelId, branchMapping, }) {
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation UpdateChannelBranchMapping($channelId: ID!, $branchMapping: String!) {
            updateChannel {
              editUpdateChannel(channelId: $channelId, branchMapping: $branchMapping) {
                id
                name
                branchMapping
              }
            }
          }
        `, { channelId, branchMapping })
        .toPromise());
    const channel = data.updateChannel.editUpdateChannel;
    if (!channel) {
        throw new Error(`Could not find a channel with id: ${channelId}`);
    }
    return data.updateChannel.editUpdateChannel;
}
exports.updateChannelBranchMappingAsync = updateChannelBranchMappingAsync;
class ChannelEdit extends EasCommand_1.default {
    async runAsync() {
        let { args: { name: channelName }, flags: { branch: branchName, json: jsonFlag }, } = await this.parse(ChannelEdit);
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        if (!channelName) {
            const validationMessage = 'A channel name is required to edit a specific channel.';
            if (jsonFlag) {
                throw new Error(validationMessage);
            }
            ({ name: channelName } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'name',
                message: 'Please enter the name of the channel to edit:',
                validate: value => (value ? true : validationMessage),
            }));
        }
        const existingChannel = await getChannelByNameForAppAsync({ appId: projectId, channelName });
        if (existingChannel.updateBranches.length > 1) {
            throw new Error('There is a rollout in progress. Please manage it with "channel:rollout" instead.');
        }
        if (!branchName) {
            const validationMessage = 'branch name may not be empty.';
            if (jsonFlag) {
                throw new Error(validationMessage);
            }
            ({ name: branchName } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'name',
                message: (0, chalk_1.default) `What branch should it change to?`,
                validate: value => (value ? true : validationMessage),
            }));
        }
        const branch = await (0, projectUtils_1.getBranchByNameAsync)({ appId: projectId, name: branchName });
        const channel = await updateChannelBranchMappingAsync({
            channelId: existingChannel.id,
            // todo: move branch mapping logic to utility
            branchMapping: JSON.stringify({
                data: [{ branchId: branch.id, branchMappingLogic: 'true' }],
                version: 0,
            }),
        });
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(channel);
        }
        else {
            log_1.default.withTick((0, chalk_1.default) `Channel {bold ${channel.name}} is now set to branch {bold ${branch.name}}.\n`);
            log_1.default.addNewLineIfNone();
            log_1.default.log((0, chalk_1.default) `Users with builds on channel {bold ${channel.name}} will now receive the active update on {bold ${branch.name}}.`);
        }
    }
}
exports.default = ChannelEdit;
ChannelEdit.description = 'Point a channel at a new branch.';
ChannelEdit.args = [
    {
        name: 'name',
        required: false,
        description: 'Name of the channel to edit',
    },
];
ChannelEdit.flags = {
    branch: core_1.Flags.string({
        description: 'Name of the branch to point to',
    }),
    json: core_1.Flags.boolean({
        description: 'print output as a JSON object with the channel ID, name and branch mapping.',
        default: false,
    }),
};
