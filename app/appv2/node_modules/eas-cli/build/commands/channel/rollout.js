"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const EasCommand_1 = (0, tslib_1.__importDefault)(require("../../commandUtils/EasCommand"));
const log_1 = (0, tslib_1.__importDefault)(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
const edit_1 = require("./edit");
const view_1 = require("./view");
async function promptForRolloutPercentAsync({ promptMessage, }) {
    const { name: rolloutPercent } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'name',
        format: value => {
            return parseInt(value, 10);
        },
        message: promptMessage,
        initial: 0,
        validate: (rolloutPercent) => {
            const floatValue = parseFloat(rolloutPercent);
            return Number.isInteger(floatValue) && floatValue >= 0 && floatValue <= 100
                ? true
                : 'The rollout percentage must be an integer between 0 and 100 inclusive.';
        },
    });
    return rolloutPercent;
}
function getRolloutInfo(getUpdateChannelByNameForAppResult) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { branchMapping } = (0, view_1.getBranchMapping)((_b = (_a = getUpdateChannelByNameForAppResult.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName) === null || _b === void 0 ? void 0 : _b.branchMapping);
    const [newBranchId, oldBranchId] = branchMapping.data.map(d => d.branchId);
    const newBranch = (_d = (_c = getUpdateChannelByNameForAppResult.app) === null || _c === void 0 ? void 0 : _c.byId.updateChannelByName) === null || _d === void 0 ? void 0 : _d.updateBranches.filter(branch => branch.id === newBranchId)[0];
    const oldBranch = (_f = (_e = getUpdateChannelByNameForAppResult.app) === null || _e === void 0 ? void 0 : _e.byId.updateChannelByName) === null || _f === void 0 ? void 0 : _f.updateBranches.filter(branch => branch.id === oldBranchId)[0];
    if (!newBranch || !oldBranch) {
        throw new Error(`Branch mapping rollout is missing a branch for channel "${(_h = (_g = getUpdateChannelByNameForAppResult.app) === null || _g === void 0 ? void 0 : _g.byId.updateChannelByName) === null || _h === void 0 ? void 0 : _h.name}".`);
    }
    const currentPercent = 100 * branchMapping.data[0].branchMappingLogic.operand;
    return { newBranch, oldBranch, currentPercent };
}
async function startRolloutAsync({ channelName, branchName, percent, jsonFlag, projectId, fullName, currentBranchMapping, getUpdateChannelByNameForAppResult, }) {
    var _a, _b, _c, _d;
    if (!branchName) {
        const validationMessage = 'A branch must be specified.';
        if (jsonFlag) {
            throw new Error(validationMessage);
        }
        ({ name: branchName } = await (0, prompts_1.promptAsync)({
            type: 'text',
            name: 'name',
            message: `Select a branch to rollout onto ${channelName}`,
            validate: value => (value ? true : validationMessage),
        }));
    }
    const branch = await (0, projectUtils_1.getBranchByNameAsync)({ appId: projectId, name: branchName });
    const oldBranchId = currentBranchMapping.data[0].branchId;
    if (branch.id === oldBranchId) {
        throw new Error(`channel "${channelName}" is already pointing at branch "${branchName}". Rollouts must be done with distinct branches.`);
    }
    if (percent == null) {
        if (jsonFlag) {
            throw new Error('You must specify a percent with the --percent flag when initiating a rollout with the --json flag.');
        }
        const promptMessage = `What percent of users should be directed to the branch "${branchName}"?`;
        percent = await promptForRolloutPercentAsync({ promptMessage });
    }
    const newBranchMapping = {
        version: 0,
        data: [
            {
                branchId: branch.id,
                branchMappingLogic: {
                    operand: percent / 100,
                    clientKey: 'rolloutToken',
                    branchMappingOperator: 'hash_lt',
                },
            },
            currentBranchMapping.data[0],
        ],
    };
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)({
        channelId: (_b = (_a = getUpdateChannelByNameForAppResult.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName) === null || _b === void 0 ? void 0 : _b.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const oldBranch = (_d = (_c = getUpdateChannelByNameForAppResult.app) === null || _c === void 0 ? void 0 : _c.byId.updateChannelByName) === null || _d === void 0 ? void 0 : _d.updateBranches.filter(branch => branch.id === oldBranchId)[0];
    if (!oldBranch) {
        throw new Error(`Branch mapping is missing its only branch for channel "${channelName}" on app "${fullName}"`);
    }
    const logMessage = `️Started a rollout of branch ${chalk_1.default.bold(branchName)} onto channel ${chalk_1.default.bold(channelName)}! ${chalk_1.default.bold(percent)}% of users will be directed to branch ${chalk_1.default.bold(branchName)}, ${chalk_1.default.bold(100 - percent)}% to branch ${chalk_1.default.bold(oldBranch.name)}.`;
    return { newChannelInfo, logMessage };
}
async function editRolloutAsync({ channelName, percent, jsonFlag, currentBranchMapping, getUpdateChannelByNameForAppResult, }) {
    var _a, _b;
    const { newBranch, oldBranch, currentPercent } = getRolloutInfo(getUpdateChannelByNameForAppResult);
    if (percent == null) {
        if (jsonFlag) {
            throw new Error('A rollout is already in progress. If you wish to modify it you must use specify the new rollout percentage with the --percent flag.');
        }
        const promptMessage = `Currently ${currentPercent}% of all users are routed to branch ${newBranch.name} and ${100 - currentPercent}% of all users are routed to branch ${oldBranch.name}. What percent of users should be directed to the branch ${newBranch.name}?`;
        percent = await promptForRolloutPercentAsync({ promptMessage });
    }
    const newBranchMapping = { ...currentBranchMapping };
    newBranchMapping.data[0].branchMappingLogic.operand = percent / 100;
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)({
        channelId: (_b = (_a = getUpdateChannelByNameForAppResult.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName) === null || _b === void 0 ? void 0 : _b.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const logMessage = `️Rollout of branch ${chalk_1.default.bold(newBranch.name)} onto channel ${chalk_1.default.bold(channelName)} updated from ${chalk_1.default.bold(currentPercent)}% to ${chalk_1.default.bold(percent)}%. ${chalk_1.default.bold(percent)}% of users will be directed to branch ${chalk_1.default.bold(newBranch.name)}, ${chalk_1.default.bold(100 - percent)}% to branch ${chalk_1.default.bold(oldBranch.name)}.`;
    return { newChannelInfo, logMessage };
}
async function endRolloutAsync({ channelName, branchName, jsonFlag, projectId, getUpdateChannelByNameForAppResult, }) {
    var _a, _b;
    // end rollout
    const { newBranch, oldBranch, currentPercent } = getRolloutInfo(getUpdateChannelByNameForAppResult);
    let endOnNewBranch;
    if (branchName) {
        const branch = await (0, projectUtils_1.getBranchByNameAsync)({ appId: projectId, name: branchName });
        switch (branch.id) {
            case newBranch.id:
                endOnNewBranch = true;
                break;
            case oldBranch.id:
                endOnNewBranch = false;
                break;
            default:
                throw new Error(`The branch "${branchName}" specified by --branch must be one of the branches involved in the rollout: "${newBranch.name}" or "${oldBranch.name}".`);
        }
    }
    else {
        if (jsonFlag) {
            throw new Error('Branch name must be specified with the --branch flag when both the --end and --json flag are true.');
        }
        endOnNewBranch = await (0, prompts_1.selectAsync)('Ending the rollout will send all traffic to a single branch. Which one should that be?', [
            {
                title: `${newBranch.name} ${chalk_1.default.grey(`- current percent: ${100 - currentPercent}%`)}`,
                value: true,
            },
            {
                title: `${oldBranch.name} ${chalk_1.default.grey(`- current percent: ${currentPercent}%`)}`,
                value: false,
            },
        ]);
    }
    if (endOnNewBranch == null) {
        throw new Error('Branch to end on is undefined.');
    }
    const newBranchMapping = {
        version: 0,
        data: [
            {
                branchId: endOnNewBranch ? newBranch.id : oldBranch.id,
                branchMappingLogic: 'true',
            },
        ],
    };
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)({
        channelId: (_b = (_a = getUpdateChannelByNameForAppResult.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName) === null || _b === void 0 ? void 0 : _b.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const logMessage = `️Rollout on channel ${chalk_1.default.bold(channelName)} ended. All traffic is now sent to branch ${chalk_1.default.bold(endOnNewBranch ? newBranch.name : oldBranch.name)}`;
    return { newChannelInfo, logMessage };
}
class ChannelRollout extends EasCommand_1.default {
    async runAsync() {
        var _a, _b;
        const { args: { channel: channelName }, flags: { json: jsonFlag, end: endFlag, branch: branchName, percent }, } = await this.parse(ChannelRollout);
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const fullName = await (0, projectUtils_1.getProjectFullNameAsync)(exp);
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        const getUpdateChannelByNameForAppResult = await (0, view_1.getUpdateChannelByNameForAppAsync)({
            appId: projectId,
            channelName: channelName,
        });
        const { branchMapping: currentBranchMapping, isRollout } = (0, view_1.getBranchMapping)((_b = (_a = getUpdateChannelByNameForAppResult.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName) === null || _b === void 0 ? void 0 : _b.branchMapping);
        if (currentBranchMapping.data.length === 0) {
            throw new Error('The channel is not pointing at any branches.');
        }
        if (currentBranchMapping.data.length > 2) {
            throw new Error('"channel:rollout" cannot handle branch mappings with more than 2 branches.');
        }
        // This combination doesn't make sense. Throw an error explaining the options.
        if (isRollout && branchName && !endFlag) {
            throw new Error(`There is a rollout in progress. You can only either edit the rollout percent or 'end' it.`);
        }
        /**
         * This if/else block has three branches:
         *  1. The branch mapping is not a rollout, i.e. it is pointing to a single branch.
         *  2. The branch mapping is a rollout.
         *    a. increase/decrease the rollout percentage.
         *    b. end the rollout.
         */
        let rolloutMutationResult;
        if (!isRollout) {
            rolloutMutationResult = await startRolloutAsync({
                channelName,
                branchName,
                percent,
                jsonFlag,
                projectId,
                fullName,
                currentBranchMapping,
                getUpdateChannelByNameForAppResult,
            });
        }
        else if (endFlag) {
            rolloutMutationResult = await endRolloutAsync({
                channelName,
                branchName,
                jsonFlag,
                projectId,
                getUpdateChannelByNameForAppResult,
            });
        }
        else {
            rolloutMutationResult = await editRolloutAsync({
                channelName,
                percent,
                jsonFlag,
                currentBranchMapping,
                getUpdateChannelByNameForAppResult,
            });
        }
        if (!rolloutMutationResult) {
            throw new Error('rollout result is empty');
        }
        const { newChannelInfo, logMessage } = rolloutMutationResult;
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(newChannelInfo);
        }
        else {
            log_1.default.withTick(logMessage);
        }
    }
}
exports.default = ChannelRollout;
ChannelRollout.hidden = true;
ChannelRollout.description = 'Rollout a new branch out to a channel incrementally.';
ChannelRollout.args = [
    {
        name: 'channel',
        required: true,
        description: 'rollout that the channel is on',
    },
];
ChannelRollout.flags = {
    branch: core_1.Flags.string({
        description: 'branch to rollout',
        required: false,
    }),
    percent: core_1.Flags.integer({
        description: 'percent of traffic to redirect to the new branch',
        required: false,
    }),
    end: core_1.Flags.boolean({
        description: 'end the rollout',
        default: false,
    }),
    json: core_1.Flags.boolean({
        description: 'print output as a JSON object with the new channel ID, name and branch mapping',
        default: false,
    }),
};
